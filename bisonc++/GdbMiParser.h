// Generated by Bisonc++ V6.04.01 on Mon, 28 Mar 2022 15:35:13 +0530

#ifndef GdbMiParser_h_included
#define GdbMiParser_h_included

// $insert baseclass
#include "GdbMiParserbase.h"
#include <string>
#include "GdiMiLexer.h"

// $insert undefparser
#undef GdbMiParser
// CAVEAT: between the baseclass-include directive and the
// #undef directive in the previous line references to GdbMiParser
// are read as GdbMiParserBase.
// If you need to include additional headers in this file
// you should do so after these comment-lines.

struct membuf : std::streambuf {
   membuf(char const *base, size_t size) {
      char *p(const_cast<char *>(base));

      this->setg(p, p, p + size);
   }
};

struct imemstream : virtual membuf, std::istream {
   imemstream(char const *base, size_t size) : membuf(base, size), std::istream(static_cast<std::streambuf *>(this)) {}
};

class GdbMiParser : public GdbMiParserBase {

 public:
   GdbMiParser() = default;
   int parse();

    auto parse(const std::string &buffer) -> GdbMiOutput * {
      imemstream d(buffer.c_str(), buffer.size() - 1);
      d_scanner = new GdiMiLexer{d};

      auto rc = parse();

      if (rc != 0) {
         std::cout << "parse failed" << std::endl;
         delete _output;
         _output = nullptr;
         return nullptr;
      }
      auto *temp = _output;
      _output    = nullptr; // memory should be owned by caller
      return temp;
   }

   auto createTuple() -> GdbMiResult * {
      auto *tuple = new GdbMiResult{GdbMiResult::VALUE_TYPE_TUPLE};
      return tuple;
   }

   auto createTuple(std::vector<GdbMiResult *> resultList) -> GdbMiResult * {
      auto *tuple = createTuple();
      std::copy(resultList.begin(), resultList.end(), std::back_inserter(tuple->_childrens));

      return tuple;
   }

   auto createList() -> GdbMiResult * {
      auto *list = new GdbMiResult{GdbMiResult::VALUE_TYPE_LIST};
      return list;
   }

   auto createList(std::vector<GdbMiResult *> &resultList) -> GdbMiResult * {
      auto *list = createList();
      std::copy(resultList.begin(), resultList.end(), std::back_inserter(list->_childrens));

      return list;
   }

   auto createConst(std::string &data) -> GdbMiResult * {
      auto *result   = new GdbMiResult{GdbMiResult::VALUE_TYPE_CONST};
      result->_const = std::move(data);
      return result;
   }

   auto createNotifyAsyncOutput(std::string &token, std::string &asyncClass, std::vector<GdbMiResult *> &resultList) -> GdbMiOutOfBandRecord * {
      auto *nao = new GdbMiAsyncRecord{GdbMiAsyncRecord::ASYNC_TYPE_NOTIFY, token, GdbMiAsyncRecord::getAsyncClass(asyncClass), resultList};
      return nao;
   }

   auto createStatusAsyncOutput(std::string &token, std::string &asyncClass, std::vector<GdbMiResult *> &resultList) -> GdbMiOutOfBandRecord * {
      auto *nao = new GdbMiAsyncRecord{GdbMiAsyncRecord::ASYNC_TYPE_STATUS, token, GdbMiAsyncRecord::getAsyncClass(asyncClass), resultList};
      return nao;
   }

   auto createExecAsyncOutput(std::string &token, std::string &asyncClass, std::vector<GdbMiResult *> &resultList) -> GdbMiOutOfBandRecord * {
      auto *nao = new GdbMiAsyncRecord{GdbMiAsyncRecord::ASYNC_TYPE_EXEC, token, GdbMiAsyncRecord::getAsyncClass(asyncClass), resultList};
      return nao;
   }

   auto createResultRecord(std::string &token, std::string &resultClass, std::vector<GdbMiResult *> &resultList) -> GdbMiResultRecord * {
      auto *nao = new GdbMiResultRecord{GdbMiResultRecord::getResultClass(resultClass), token, resultList};
      return nao;
   }

   auto setOutput(std::vector<GdbMiOutOfBandRecord *> &oobList, GdbMiResultRecord *resultRecord) -> GdbMiOutput * {
      _output = new GdbMiOutput{oobList, resultRecord};
      return _output;
   }

   auto createConsoleStreamOutput(std::string &data) -> GdbMiStreamRecord * { return new GdbMiStreamRecord{GdbMiStreamRecord::STREAM_TYPE_CONSOLE, data}; }

   auto createTargetStreamOutput(std::string &data) -> GdbMiStreamRecord * { return new GdbMiStreamRecord{GdbMiStreamRecord::STREAM_TYPE_TARGET, data}; }

   auto createLogStreamOutput(std::string &data) -> GdbMiStreamRecord * { return new GdbMiStreamRecord{GdbMiStreamRecord::STREAM_TYPE_LOG, data}; }

 private:
   void error(); // called on (syntax) errors
   int  lex();   // returns the next token from the
                 // lexical scanner.
   void print(); // use, e.g., d_token, d_loc
   void exceptionHandler(std::exception const &exc);

   // support functions for parse():
   void executeAction_(int ruleNr);
   void errorRecovery_();
   void nextCycle_();
   void nextToken_();
   void print_();

   GdiMiLexer *d_scanner = nullptr;
    GdbMiOutput * _output = nullptr;
};

#endif
